{"version":3,"file":"remark-slate.esm.js","sources":["../src/deserialize.ts","../src/serialize.ts","../src/plugin.ts"],"sourcesContent":["export interface NodeTypes {\n  paragraph?: string;\n  block_quote?: string;\n  code_block?: string;\n  link?: string;\n  ul_list?: string;\n  ol_list?: string;\n  listItem?: string;\n  heading?: {\n    1?: string;\n    2?: string;\n    3?: string;\n    4?: string;\n    5?: string;\n    6?: string;\n  };\n  emphasis_mark?: string;\n  strong_mark?: string;\n  delete_mark?: string;\n}\n\nexport interface OptionType {\n  nodeTypes?: NodeTypes;\n  linkDestinationKey?: string;\n}\n\nexport interface MdastNode {\n  type?: string;\n  ordered?: boolean;\n  value?: string;\n  text?: string;\n  children?: Array<MdastNode>;\n  depth?: 1 | 2 | 3 | 4 | 5 | 6;\n  url?: string;\n  lang?: string;\n  // mdast metadata\n  position?: any;\n  spread?: any;\n  checked?: any;\n  indent?: any;\n}\n\nexport const defaultNodeTypes = {\n  paragraph: 'paragraph',\n  block_quote: 'block_quote',\n  code_block: 'code_block',\n  link: 'link',\n  ul_list: 'ul_list',\n  ol_list: 'ol_list',\n  listItem: 'list_item',\n  heading: {\n    1: 'heading_one',\n    2: 'heading_two',\n    3: 'heading_three',\n    4: 'heading_four',\n    5: 'heading_five',\n    6: 'heading_six',\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikeThrough',\n};\n\nexport default function deserialize(\n  node: MdastNode,\n  opts: OptionType = { nodeTypes: {} }\n) {\n  const types = {\n    ...defaultNodeTypes,\n    ...opts.nodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...opts?.nodeTypes?.heading,\n    },\n  };\n\n  const linkDestinationKey = opts.linkDestinationKey ?? 'link';\n\n  let children = [{ text: '' }];\n\n  if (\n    node.children &&\n    Array.isArray(node.children) &&\n    node.children.length > 0\n  ) {\n    // @ts-ignore\n    children = node.children.map((c: MdastNode) =>\n      deserialize(\n        {\n          ...c,\n          ordered: node.ordered || false,\n        },\n        opts\n      )\n    );\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return { type: types.heading[node.depth || 1], children };\n    case 'list':\n      return { type: node.ordered ? types.ol_list : types.ul_list, children };\n    case 'listItem':\n      return { type: types.listItem, children };\n    case 'paragraph':\n      return { type: types.paragraph, children };\n    case 'link':\n      return { type: types.link, [linkDestinationKey]: node.url, children };\n    case 'blockquote':\n      return { type: types.block_quote, children };\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{ text: node.value }],\n      };\n\n    case 'html':\n      if (node.value?.includes('<br>')) {\n        return {\n          break: true,\n          type: types.paragraph,\n          children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n        };\n      }\n      // TODO: Handle other HTML?\n      return { type: 'paragraph', children: [{ text: '' }] };\n\n    case 'emphasis':\n      return {\n        [types.emphasis_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'strong':\n      return {\n        [types.strong_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'delete':\n      return {\n        [types.delete_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n\n    case 'text':\n    default:\n      return { text: node.value || '' };\n  }\n}\n\nconst forceLeafNode = (children: Array<{ text?: string }>) => ({\n  text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nfunction persistLeafFormats(children: Array<MdastNode>) {\n  return children.reduce((acc, node) => {\n    Object.keys(node).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return;\n\n      // @ts-ignore\n      acc[key] = node[key];\n    });\n\n    return acc;\n  }, {});\n}\n","import escapeHtml from 'escape-html';\n\nimport { defaultNodeTypes, NodeTypes } from './deserialize';\n\nexport interface LeafType {\n  text: string;\n  strikeThrough?: boolean;\n  bold?: boolean;\n  italic?: boolean;\n  parentType?: string;\n}\n\nexport interface BlockType {\n  type: string;\n  parentType?: string;\n  link?: string;\n  language?: string;\n  break?: boolean;\n  children: Array<BlockType | LeafType>;\n}\n\ninterface Options {\n  nodeTypes: NodeTypes;\n  listDepth?: number;\n  ignoreParagraphNewline?: boolean;\n}\n\nconst isLeafNode = (node: BlockType | LeafType): node is LeafType => {\n  return typeof (node as LeafType).text === 'string';\n};\n\nconst BREAK_TAG = '<br>';\n\nexport default function serialize(\n  chunk: BlockType | LeafType,\n  opts: Options = { nodeTypes: defaultNodeTypes }\n) {\n  const {\n    nodeTypes: userNodeTypes = defaultNodeTypes,\n    ignoreParagraphNewline = false,\n    listDepth = 0,\n  } = opts;\n\n  let text = (chunk as LeafType).text || '';\n  let type = (chunk as BlockType).type || '';\n\n  const nodeTypes = {\n    ...defaultNodeTypes,\n    ...userNodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...userNodeTypes.heading,\n    },\n  };\n\n  const LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n\n  let children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children\n      .map((c: BlockType | LeafType) => {\n        const isList = !isLeafNode(c)\n          ? LIST_TYPES.includes(c.type || '')\n          : false;\n\n        const selfIsList = LIST_TYPES.includes(chunk.type || '');\n\n        // Links can have the following shape\n        // In which case we don't want to surround\n        // with break tags\n        // {\n        //  type: 'paragraph',\n        //  children: [\n        //    { text: '' },\n        //    { type: 'link', children: [{ text: foo.com }]}\n        //    { text: '' }\n        //  ]\n        // }\n        let childrenHasLink = false;\n\n        if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n          childrenHasLink = chunk.children.some(\n            (f) => !isLeafNode(f) && f.type === nodeTypes.link\n          );\n        }\n\n        return serialize(\n          { ...c, parentType: type },\n          {\n            nodeTypes,\n            // WOAH.\n            // what we're doing here is pretty tricky, it relates to the block below where\n            // we check for ignoreParagraphNewline and set type to paragraph.\n            // We want to strip out empty paragraphs sometimes, but other times we don't.\n            // If we're the descendant of a list, we know we don't want a bunch\n            // of whitespace. If we're parallel to a link we also don't want\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              (ignoreParagraphNewline ||\n                isList ||\n                selfIsList ||\n                childrenHasLink) &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as BlockType).break,\n\n            // track depth of nested lists so we can add proper spacing\n            listDepth: LIST_TYPES.includes((c as BlockType).type || '')\n              ? listDepth + 1\n              : listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    chunk.parentType === nodeTypes.paragraph\n  ) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '') return;\n\n  // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikeThrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikeThrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return `# ${children}\\n`;\n    case nodeTypes.heading[2]:\n      return `## ${children}\\n`;\n    case nodeTypes.heading[3]:\n      return `### ${children}\\n`;\n    case nodeTypes.heading[4]:\n      return `#### ${children}\\n`;\n    case nodeTypes.heading[5]:\n      return `##### ${children}\\n`;\n    case nodeTypes.heading[6]:\n      return `###### ${children}\\n`;\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return `> ${children}\\n\\n`;\n\n    case nodeTypes.code_block:\n      return `\\`\\`\\`${\n        (chunk as BlockType).language || ''\n      }\\n${children}\\n\\`\\`\\`\\n`;\n\n    case nodeTypes.link:\n      return `[${children}](${(chunk as BlockType).link || ''})`;\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return `\\n${children}\\n`;\n\n    case nodeTypes.listItem:\n      const isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n\n      let spacer = '';\n      for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n      return `${spacer}${isOL ? '1.' : '-'} ${children}`;\n\n    case nodeTypes.paragraph:\n      return `${children}\\n`;\n\n    default:\n      return escapeHtml(children);\n  }\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nfunction retainWhitespaceAndFormat(string: string, format: string) {\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  let children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${format}${children}${reverseStr(format)}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = format + children + reverseStr(format);\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import transform, { OptionType, MdastNode } from './deserialize';\n\nexport default function plugin(opts?: OptionType) {\n  const compiler = (node: { children: Array<MdastNode> }) => {\n    return node.children.map((c) => transform(c, opts));\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n"],"names":["defaultNodeTypes","paragraph","block_quote","code_block","link","ul_list","ol_list","listItem","heading","emphasis_mark","strong_mark","delete_mark","deserialize","node","opts","nodeTypes","types","linkDestinationKey","children","text","Array","isArray","length","map","c","ordered","type","depth","url","language","lang","value","includes","replace","forceLeafNode","persistLeafFormats","k","join","reduce","acc","Object","keys","forEach","key","isLeafNode","BREAK_TAG","serialize","chunk","userNodeTypes","ignoreParagraphNewline","listDepth","LIST_TYPES","isList","selfIsList","childrenHasLink","some","f","parentType","strikeThrough","bold","italic","retainWhitespaceAndFormat","isOL","spacer","escapeHtml","string","format","frozenString","trim","fullFormat","reverseStr","formattedString","split","reverse","plugin","compiler","transform","Compiler"],"mappings":"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"}