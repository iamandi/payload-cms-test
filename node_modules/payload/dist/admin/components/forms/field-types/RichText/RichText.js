import React, { useState, useCallback, useMemo, useEffect } from 'react';
import isHotkey from 'is-hotkey';
import { Editable, withReact, Slate } from 'slate-react';
import { createEditor } from 'slate';
import { withHistory } from 'slate-history';
import { richText } from '../../../../../fields/validations';
import useFieldType from '../../useFieldType';
import withCondition from '../../withCondition';
import Label from '../../Label';
import Error from '../../Error';
import leafTypes from './leaves';
import elementTypes from './elements';
import toggleLeaf from './leaves/toggle';
import hotkeys from './hotkeys';
import enablePlugins from './enablePlugins';
import defaultValue from '../../../../../fields/richText/defaultValue';
import FieldTypeGutter from '../../FieldTypeGutter';
import withHTML from './plugins/withHTML';
import mergeCustomFunctions from './mergeCustomFunctions';
import './index.scss';
const defaultElements = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'link', 'relationship'];
const defaultLeaves = ['bold', 'italic', 'underline', 'strikethrough', 'code'];
const baseClass = 'rich-text';
const RichText = (props) => {
    const { path: pathFromProps, name, required, validate = richText, label, admin, admin: { readOnly, style, width, placeholder, } = {}, } = props;
    const elements = admin?.elements || defaultElements;
    const leaves = admin?.leaves || defaultLeaves;
    const path = pathFromProps || name;
    const [loaded, setLoaded] = useState(false);
    const [enabledElements, setEnabledElements] = useState({});
    const [enabledLeaves, setEnabledLeaves] = useState({});
    const renderElement = useCallback(({ attributes, children, element }) => {
        const matchedElement = enabledElements[element?.type];
        const Element = matchedElement?.Element;
        if (Element) {
            return (React.createElement(Element, { attributes: attributes, element: element }, children));
        }
        return React.createElement("div", Object.assign({}, attributes), children);
    }, [enabledElements]);
    const renderLeaf = useCallback(({ attributes, children, leaf }) => {
        const matchedLeafName = Object.keys(enabledLeaves).find((leafName) => leaf[leafName]);
        if (enabledLeaves[matchedLeafName]?.Leaf) {
            const { Leaf } = enabledLeaves[matchedLeafName];
            return (React.createElement(Leaf, { attributes: attributes, leaf: leaf }, children));
        }
        return (React.createElement("span", Object.assign({}, attributes), children));
    }, [enabledLeaves]);
    const memoizedValidate = useCallback((value) => {
        const validationResult = validate(value, { required });
        return validationResult;
    }, [validate, required]);
    const fieldType = useFieldType({
        path,
        validate: memoizedValidate,
        stringify: true,
    });
    const { value, showError, setValue, errorMessage, } = fieldType;
    const classes = [
        baseClass,
        'field-type',
        showError && 'error',
        readOnly && `${baseClass}--read-only`,
    ].filter(Boolean).join(' ');
    const editor = useMemo(() => {
        let CreatedEditor = withHTML(withHistory(withReact(createEditor())));
        CreatedEditor = enablePlugins(CreatedEditor, elements);
        CreatedEditor = enablePlugins(CreatedEditor, leaves);
        return CreatedEditor;
    }, [elements, leaves]);
    useEffect(() => {
        if (!loaded) {
            const mergedElements = mergeCustomFunctions(elements, elementTypes);
            const mergedLeaves = mergeCustomFunctions(leaves, leafTypes);
            setEnabledElements(mergedElements);
            setEnabledLeaves(mergedLeaves);
            setLoaded(true);
        }
    }, [loaded, elements, leaves]);
    if (!loaded) {
        return null;
    }
    let valueToRender = value;
    if (typeof valueToRender === 'string')
        valueToRender = JSON.parse(valueToRender);
    if (!valueToRender)
        valueToRender = defaultValue;
    return (React.createElement("div", { className: classes, style: {
            ...style,
            width,
        } },
        React.createElement(FieldTypeGutter, null),
        React.createElement("div", { className: `${baseClass}__wrap` },
            React.createElement(Error, { showError: showError, message: errorMessage }),
            React.createElement(Label, { htmlFor: path, label: label, required: required }),
            React.createElement(Slate, { editor: editor, value: valueToRender, onChange: (val) => {
                    if (val !== defaultValue && val !== value) {
                        setValue(val);
                    }
                } },
                React.createElement("div", { className: `${baseClass}__wrapper` },
                    React.createElement("div", { className: `${baseClass}__toolbar` },
                        elements.map((element, i) => {
                            let elementName;
                            if (typeof element === 'object' && element?.name)
                                elementName = element.name;
                            if (typeof element === 'string')
                                elementName = element;
                            const elementType = enabledElements[elementName];
                            const Button = elementType?.Button;
                            if (Button) {
                                return (React.createElement(Button, { key: i, path: path }));
                            }
                            return null;
                        }),
                        leaves.map((leaf, i) => {
                            let leafName;
                            if (typeof leaf === 'object' && leaf?.name)
                                leafName = leaf.name;
                            if (typeof leaf === 'string')
                                leafName = leaf;
                            const leafType = enabledLeaves[leafName];
                            const Button = leafType?.Button;
                            if (Button) {
                                return (React.createElement(Button, { key: i, path: path }));
                            }
                            return null;
                        })),
                    React.createElement(Editable, { className: `${baseClass}__editor`, renderElement: renderElement, renderLeaf: renderLeaf, placeholder: placeholder, spellCheck: true, readOnly: readOnly, onKeyDown: (event) => {
                            Object.keys(hotkeys).forEach((hotkey) => {
                                if (isHotkey(hotkey, event)) {
                                    event.preventDefault();
                                    const mark = hotkeys[hotkey];
                                    toggleLeaf(editor, mark);
                                }
                            });
                        } }))))));
};
export default withCondition(RichText);
