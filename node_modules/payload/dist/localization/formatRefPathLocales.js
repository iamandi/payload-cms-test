"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function formatRefPathLocales(schema, parentSchema, parentPath) {
    // Loop through all refPaths within schema
    schema.eachPath((pathname, schemaType) => {
        // If a dynamic refPath is found
        if (schemaType.options.refPath && schemaType.options.refPath.includes('{{LOCALE}}') && parentSchema) {
            // Create a clone of the schema for each locale
            const newSchema = schema.clone();
            // Remove the old pathname in order to rebuild it after it's formatted
            newSchema.remove(pathname);
            // Get the locale from the parent path
            let locale = parentPath;
            // Split the parent path and take only the last segment as locale
            if (parentPath && parentPath.includes('.')) {
                locale = parentPath.split('.').pop();
            }
            // Replace {{LOCALE}} appropriately
            const refPath = schemaType.options.refPath.replace('{{LOCALE}}', locale);
            // Add new schemaType back to newly cloned schema
            newSchema.add({
                [pathname]: {
                    ...schemaType.options,
                    refPath,
                },
            });
            // Removing and adding a path to a schema does not update tree, so do it manually
            newSchema.tree[pathname].refPath = refPath;
            const parentSchemaType = parentSchema.path(parentPath).instance;
            // Remove old schema from parent
            parentSchema.remove(parentPath);
            // Replace newly cloned and updated schema on parent
            parentSchema.add({
                [parentPath]: parentSchemaType === 'Array' ? [newSchema] : newSchema,
            });
        }
        // If nested schema found, continue recursively
        if (schemaType.schema) {
            formatRefPathLocales(schemaType.schema, schema, pathname);
        }
    });
}
exports.default = formatRefPathLocales;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0UmVmUGF0aExvY2FsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbG9jYWxpemF0aW9uL2Zvcm1hdFJlZlBhdGhMb2NhbGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsU0FBd0Isb0JBQW9CLENBQUMsTUFBTSxFQUFFLFlBQWtCLEVBQUUsVUFBbUI7SUFDMUYsMENBQTBDO0lBQzFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDdkMsZ0NBQWdDO1FBQ2hDLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLFlBQVksRUFBRTtZQUNuRywrQ0FBK0M7WUFDL0MsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRWpDLHNFQUFzRTtZQUN0RSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTNCLHNDQUFzQztZQUN0QyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUM7WUFFeEIsaUVBQWlFO1lBQ2pFLElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzFDLE1BQU0sR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQ3RDO1lBRUQsbUNBQW1DO1lBQ25DLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFekUsaURBQWlEO1lBQ2pELFNBQVMsQ0FBQyxHQUFHLENBQUM7Z0JBQ1osQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDVixHQUFHLFVBQVUsQ0FBQyxPQUFPO29CQUNyQixPQUFPO2lCQUNSO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsaUZBQWlGO1lBQ2pGLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztZQUUzQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDO1lBRWhFLGdDQUFnQztZQUNoQyxZQUFZLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBRWhDLG9EQUFvRDtZQUNwRCxZQUFZLENBQUMsR0FBRyxDQUFDO2dCQUNmLENBQUMsVUFBVSxDQUFDLEVBQUUsZ0JBQWdCLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO2FBQ3JFLENBQUMsQ0FBQztTQUNKO1FBRUQsK0NBQStDO1FBQy9DLElBQUksVUFBVSxDQUFDLE1BQU0sRUFBRTtZQUNyQixvQkFBb0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztTQUMzRDtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWpERCx1Q0FpREMifQ==